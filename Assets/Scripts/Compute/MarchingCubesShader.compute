// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ProcessMarchingCube
#include "/MarchTables.compute"

struct Triangle {
    float3 v0;
    float3 v1;
    float3 v2;
};

float Threshold;
RWTexture3D<float> NoiseMap;
AppendStructuredBuffer<Triangle> VertexBuffer;

static const int3 corners[8] = {
    int3(0, 0, 0),
    int3(1, 0, 0),
    int3(1, 0, 1),
    int3(0, 0, 1),
    int3(0, 1, 0),
    int3(1, 1, 0),
    int3(1, 1, 1),
    int3(0, 1, 1)
};

static const int2 edges[12] = {
    int2(0, 1),
    int2(1, 2),
    int2(2, 3),
    int2(3, 0),
    int2(4, 5),
    int2(5, 6),
    int2(6, 7),
    int2(7, 4),
    int2(0, 4),
    int2(1, 5),
    int2(2, 6),
    int2(3, 7)
};

[numthreads(8,8,8)]
void ProcessMarchingCube (uint3 id : SV_DispatchThreadID) {
    int cubeIndex = 0;
    [unroll]
    for (int i = 0; i < 8; i++) {
        int3 corner = corners[i] + id;
        float value = NoiseMap[id+corner];
        if (value > Threshold) {
            cubeIndex |= 1 << i;
        }
    }

    int edgeIndices[16] = triangulation[cubeIndex];

    for (int t = 0; t < 5; t += 3) {
        if (edgeIndices[t*3] == -1) break;
        float3 vertices[3];
        for (int v = 0; v < 3; v++) {
            int edgeIndex = edgeIndices[t*3 + v];
            int2 edgeCorners = edges[edgeIndex];
            int3 edgeStart = corners[edgeCorners.x] + id;
            int3 edgeEnd = corners[edgeCorners.y] + id;
            float3 vertex = lerp(edgeStart, edgeEnd, 0.5);
            vertices[v] = vertex;
        }
        Triangle tri;
        tri.v0 = vertices[0];
        tri.v1 = vertices[1];
        tri.v2 = vertices[2];
        VertexBuffer.Append(tri);
    }
}

